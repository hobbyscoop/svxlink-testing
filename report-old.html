<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>report-old.html</title>
    <style>body {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
  /* do not increase min-width as some may use split screens */
  min-width: 800px;
  color: #999;
}

h1 {
  font-size: 24px;
  color: black;
}

h2 {
  font-size: 16px;
  color: black;
}

p {
  color: black;
}

a {
  color: #999;
}

table {
  border-collapse: collapse;
}

/******************************
 * SUMMARY INFORMATION
 ******************************/
#environment td {
  padding: 5px;
  border: 1px solid #E6E6E6;
}
#environment tr:nth-child(odd) {
  background-color: #f6f6f6;
}

/******************************
 * TEST RESULT COLORS
 ******************************/
span.passed,
.passed .col-result {
  color: green;
}

span.skipped,
span.xfailed,
span.rerun,
.skipped .col-result,
.xfailed .col-result,
.rerun .col-result {
  color: orange;
}

span.error,
span.failed,
span.xpassed,
.error .col-result,
.failed .col-result,
.xpassed .col-result {
  color: red;
}

/******************************
 * RESULTS TABLE
 *
 * 1. Table Layout
 * 2. Extra
 * 3. Sorting items
 *
 ******************************/
/*------------------
 * 1. Table Layout
 *------------------*/
#results-table {
  border: 1px solid #e6e6e6;
  color: #999;
  font-size: 12px;
  width: 100%;
}
#results-table th,
#results-table td {
  padding: 5px;
  border: 1px solid #E6E6E6;
  text-align: left;
}
#results-table th {
  font-weight: bold;
}

/*------------------
 * 2. Extra
 *------------------*/
.log {
  background-color: #e6e6e6;
  border: 1px solid #e6e6e6;
  color: black;
  display: block;
  font-family: "Courier New", Courier, monospace;
  height: 230px;
  overflow-y: scroll;
  padding: 5px;
  white-space: pre-wrap;
}
.log:only-child {
  height: inherit;
}

div.image {
  border: 1px solid #e6e6e6;
  float: right;
  height: 240px;
  margin-left: 5px;
  overflow: hidden;
  width: 320px;
}
div.image img {
  width: 320px;
}

div.video {
  border: 1px solid #e6e6e6;
  float: right;
  height: 240px;
  margin-left: 5px;
  overflow: hidden;
  width: 320px;
}
div.video video {
  overflow: hidden;
  width: 320px;
  height: 240px;
}

.collapsed {
  display: none;
}

.expander::after {
  content: " (show details)";
  color: #BBB;
  font-style: italic;
  cursor: pointer;
}

.collapser::after {
  content: " (hide details)";
  color: #BBB;
  font-style: italic;
  cursor: pointer;
}

/*------------------
 * 3. Sorting items
 *------------------*/
.sortable {
  cursor: pointer;
}

.sort-icon {
  font-size: 0px;
  float: left;
  margin-right: 5px;
  margin-top: 5px;
  /*triangle*/
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
}
.inactive .sort-icon {
  /*finish triangle*/
  border-top: 8px solid #E6E6E6;
}
.asc.active .sort-icon {
  /*finish triangle*/
  border-bottom: 8px solid #999;
}
.desc.active .sort-icon {
  /*finish triangle*/
  border-top: 8px solid #999;
}
</style></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    let visibleString = getQueryParameter('visible') || 'all';
    visibleString = visibleString.toLowerCase();
    const checkedItems = visibleString.split(',');

    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++) {
        filterItems[i].hidden = false;

        if (visibleString != 'all') {
            filterItems[i].checked = checkedItems.includes(filterItems[i].getAttribute('data-test-result'));
            filterTable(filterItems[i]);
        }
    }
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>report-old.html</h1>
    <p>Report generated on 24-Oct-2024 at 07:06:55 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.2.0</p>
    <h2>Summary</h2>
    <p>0 tests ran in 0.89 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">0 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">0 failed</span>, <input checked="true" class="filter" data-test-result="error" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">12 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_disable_deselect_off::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6dfd010&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6dfd010&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6dfd090&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6dfd090&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6dfd010&gt;<br/>start = 1729753615.200026<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6dfd010&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_disable_deselect_off&gt;<br/>args = (&#x27;test_disable_deselect_off&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6dfc7d0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_disable_deselect_switchover::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69e1a90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69e1a90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69e1b50&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69e1b50&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69e1a90&gt;<br/>start = 1729753615.2956495<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69e1a90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_disable_deselect_switchover&gt;<br/>args = (&#x27;test_disable_deselect_switchover&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69e1190&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_dont_switchover_with_squelch::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6991b90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6991b90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6991c50&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6991c50&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6991b90&gt;<br/>start = 1729753615.3499928<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6991b90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_dont_switchover_with_squelch&gt;<br/>args = (&#x27;test_dont_switchover_with_squelch&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6991290&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_reselect_open_disable_enable::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69d95d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69d95d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69d9690&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69d9690&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69d95d0&gt;<br/>start = 1729753615.402596<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69d95d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_reselect_open_disable_enable&gt;<br/>args = (&#x27;test_reselect_open_disable_enable&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69d8cd0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_reselect_open_disable_enable_interrupt::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6b6a410&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6b6a410&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6b6a4d0&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6b6a4d0&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6b6a410&gt;<br/>start = 1729753615.4565895<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6b6a410&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_reselect_open_disable_enable_interrupt&gt;<br/>args = (&#x27;test_reselect_open_disable_enable_interrupt&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6b69b10&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_select_disable_open_enable::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6ab57d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6ab57d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6ab6ed0&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6ab6ed0&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6ab57d0&gt;<br/>start = 1729753615.5245671<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6ab57d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_select_disable_open_enable&gt;<br/>args = (&#x27;test_select_disable_open_enable&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6ab7190&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_send_all_fields_when_rx_disabled::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69ba190&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69ba190&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69ba390&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69ba390&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69ba190&gt;<br/>start = 1729753615.5795965<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69ba190&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_send_all_fields_when_rx_disabled&gt;<br/>args = (&#x27;test_send_all_fields_when_rx_disabled&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69bb7d0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_send_all_fields_when_rx_disabled_no_tx::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6a5f890&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6a5f890&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6a5f8d0&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6a5f8d0&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6a5f890&gt;<br/>start = 1729753615.6342325<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6a5f890&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_send_all_fields_when_rx_disabled_no_tx&gt;<br/>args = (&#x27;test_send_all_fields_when_rx_disabled_no_tx&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6a5ea90&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_status_update_on_disable_no_tx::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6baef90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6baef90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6baf050&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6baf050&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6baef90&gt;<br/>start = 1729753615.687637<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6baef90&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_status_update_on_disable_no_tx&gt;<br/>args = (&#x27;test_status_update_on_disable_no_tx&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bae690&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_switchback_to_higher_with_squelch::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69424d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69424d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6942590&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6942590&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69424d0&gt;<br/>start = 1729753615.7539496<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69424d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_switchback_to_higher_with_squelch&gt;<br/>args = (&#x27;test_switchback_to_higher_with_squelch&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6941b50&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_switchback_to_lower_with_squelch::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69a2c50&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69a2c50&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69a2d10&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab69a2d10&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69a2c50&gt;<br/>start = 1729753615.8081884<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab69a2c50&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_switchback_to_lower_with_squelch&gt;<br/>args = (&#x27;test_switchback_to_lower_with_squelch&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab69a22d0&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody>
      <tbody class="error results-table-row">
        <tr>
          <td class="col-result">Error</td>
          <td class="col-name">tests/test_original.py::Test::test_switchover_with_squelch::setup</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6bbde10&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>&gt;           conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6bbde10&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, verify = True, proxies = OrderedDict()<br/>cert = None<br/><br/>    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):<br/>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.<br/>        This should not be called from user code, and is only exposed for use<br/>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.<br/>    <br/>        :param request:<br/>            The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to be sent<br/>            over the connection.<br/>        :param verify:<br/>            Either a boolean, in which case it controls whether we verify the<br/>            server&#x27;s TLS certificate, or a string, in which case it must be a<br/>            path to a CA bundle to use.<br/>        :param proxies:<br/>            (optional) The proxies dictionary to apply to the request.<br/>        :param cert:<br/>            (optional) Any user-provided SSL certificate to be used for client<br/>            authentication (a.k.a., mTLS).<br/>        :rtype:<br/>            urllib3.ConnectionPool<br/>        &quot;&quot;&quot;<br/>        proxy = select_proxy(request.url, proxies)<br/>        try:<br/>            host_params, pool_kwargs = self.build_connection_pool_key_attributes(<br/>                request,<br/>                verify,<br/>                cert,<br/>            )<br/>        except ValueError as e:<br/>            raise InvalidURL(e, request=request)<br/>        if proxy:<br/>            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)<br/>            proxy_url = parse_url(proxy)<br/>            if not proxy_url.host:<br/>                raise InvalidProxyURL(<br/>                    &quot;Please check proxy URL. It is malformed &quot;<br/>                    &quot;and could be missing the host.&quot;<br/>                )<br/>            proxy_manager = self.proxy_manager_for(proxy)<br/>            conn = proxy_manager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/>        else:<br/>            # Only scheme should be lower case<br/>&gt;           conn = self.poolmanager.connection_from_host(<br/>                **host_params, pool_kwargs=pool_kwargs<br/>            )<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:489: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6bbded0&gt;<br/>host = &#x27;localhost&#x27;, port = 80, scheme = &#x27;http+docker&#x27;<br/>pool_kwargs = {&#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;ssl_context&#x27;: &lt;ssl.SSLContext object at 0x7f9ab6e39be0&gt;}<br/><br/>    def connection_from_host(<br/>        self,<br/>        host: str | None,<br/>        port: int | None = None,<br/>        scheme: str | None = &quot;http&quot;,<br/>        pool_kwargs: dict[str, typing.Any] | None = None,<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.<br/>    <br/>        If ``port`` isn&#x27;t given, it will be derived from the ``scheme`` using<br/>        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is<br/>        provided, it is merged with the instance&#x27;s ``connection_pool_kw``<br/>        variable and used to create the new connection pool, if one is<br/>        needed.<br/>        &quot;&quot;&quot;<br/>    <br/>        if not host:<br/>            raise LocationValueError(&quot;No host specified.&quot;)<br/>    <br/>        request_context = self._merge_pool_kwargs(pool_kwargs)<br/>        request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;<br/>        if not port:<br/>            port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)<br/>        request_context[&quot;port&quot;] = port<br/>        request_context[&quot;host&quot;] = host<br/>    <br/>&gt;       return self.connection_from_context(request_context)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:303: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;urllib3.poolmanager.PoolManager object at 0x7f9ab6bbded0&gt;<br/>request_context = {&#x27;block&#x27;: False, &#x27;cert_reqs&#x27;: &#x27;CERT_REQUIRED&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;maxsize&#x27;: 10, ...}<br/><br/>    def connection_from_context(<br/>        self, request_context: dict[str, typing.Any]<br/>    ) -&gt; HTTPConnectionPool:<br/>        &quot;&quot;&quot;<br/>        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.<br/>    <br/>        ``request_context`` must at least contain the ``scheme`` key and its<br/>        value must be a key in ``key_fn_by_scheme`` instance variable.<br/>        &quot;&quot;&quot;<br/>        if &quot;strict&quot; in request_context:<br/>            warnings.warn(<br/>                &quot;The &#x27;strict&#x27; parameter is no longer needed on Python 3+. &quot;<br/>                &quot;This will raise an error in urllib3 v2.1.0.&quot;,<br/>                DeprecationWarning,<br/>            )<br/>            request_context.pop(&quot;strict&quot;)<br/>    <br/>        scheme = request_context[&quot;scheme&quot;].lower()<br/>        pool_key_constructor = self.key_fn_by_scheme.get(scheme)<br/>        if not pool_key_constructor:<br/>&gt;           raise URLSchemeUnknown(scheme)<br/><span class="error">E           urllib3.exceptions.URLSchemeUnknown: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/urllib3/poolmanager.py:325: URLSchemeUnknown<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>&gt;           return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:214: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;<br/>api_version = False<br/><br/>    def version(self, api_version=True):<br/>        &quot;&quot;&quot;<br/>        Returns version information from the server. Similar to the ``docker<br/>        version`` command.<br/>    <br/>        Returns:<br/>            (dict): The server version information<br/>    <br/>        Raises:<br/>            :py:class:`docker.errors.APIError`<br/>                If the server returns an error.<br/>        &quot;&quot;&quot;<br/>        url = self._url(&quot;/version&quot;, versioned_api=api_version)<br/>&gt;       return self._result(self._get(url), json=True)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/daemon.py:181: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;<br/>args = (&#x27;http+docker://localhost/version&#x27;,), kwargs = {}<br/><br/>    def inner(self, *args, **kwargs):<br/>        if &#x27;HttpHeaders&#x27; in self._general_configs:<br/>            if not kwargs.get(&#x27;headers&#x27;):<br/>                kwargs[&#x27;headers&#x27;] = self._general_configs[&#x27;HttpHeaders&#x27;]<br/>            else:<br/>                kwargs[&#x27;headers&#x27;].update(self._general_configs[&#x27;HttpHeaders&#x27;])<br/>&gt;       return f(self, *args, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/utils/decorators.py:46: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;, kwargs = {&#x27;timeout&#x27;: 60}<br/><br/>    @update_headers<br/>    def _get(self, url, **kwargs):<br/>&gt;       return self.get(url, **self._set_request_timeout(kwargs))<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:237: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;<br/>url = &#x27;http+docker://localhost/version&#x27;<br/>kwargs = {&#x27;allow_redirects&#x27;: True, &#x27;timeout&#x27;: 60}<br/><br/>    def get(self, url, **kwargs):<br/>        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.<br/>    <br/>        :param url: URL for the new :class:`Request` object.<br/>        :param \*\*kwargs: Optional arguments that ``request`` takes.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        kwargs.setdefault(&quot;allow_redirects&quot;, True)<br/>&gt;       return self.request(&quot;GET&quot;, url, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:602: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;, method = &#x27;GET&#x27;<br/>url = &#x27;http+docker://localhost/version&#x27;, params = None, data = None<br/>headers = None, cookies = None, files = None, auth = None, timeout = 60<br/>allow_redirects = True, proxies = {}, hooks = None, stream = None, verify = None<br/>cert = None, json = None<br/><br/>    def request(<br/>        self,<br/>        method,<br/>        url,<br/>        params=None,<br/>        data=None,<br/>        headers=None,<br/>        cookies=None,<br/>        files=None,<br/>        auth=None,<br/>        timeout=None,<br/>        allow_redirects=True,<br/>        proxies=None,<br/>        hooks=None,<br/>        stream=None,<br/>        verify=None,<br/>        cert=None,<br/>        json=None,<br/>    ):<br/>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.<br/>        Returns :class:`Response &lt;Response&gt;` object.<br/>    <br/>        :param method: method for the new :class:`Request` object.<br/>        :param url: URL for the new :class:`Request` object.<br/>        :param params: (optional) Dictionary or bytes to be sent in the query<br/>            string for the :class:`Request`.<br/>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like<br/>            object to send in the body of the :class:`Request`.<br/>        :param json: (optional) json to send in the body of the<br/>            :class:`Request`.<br/>        :param headers: (optional) Dictionary of HTTP Headers to send with the<br/>            :class:`Request`.<br/>        :param cookies: (optional) Dict or CookieJar object to send with the<br/>            :class:`Request`.<br/>        :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects``<br/>            for multipart encoding upload.<br/>        :param auth: (optional) Auth tuple or callable to enable<br/>            Basic/Digest/Custom HTTP Auth.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple<br/>        :param allow_redirects: (optional) Set to True by default.<br/>        :type allow_redirects: bool<br/>        :param proxies: (optional) Dictionary mapping protocol or protocol and<br/>            hostname to the URL of the proxy.<br/>        :param hooks: (optional) Dictionary mapping hook name to one event or<br/>            list of events, event must be callable.<br/>        :param stream: (optional) whether to immediately download the response<br/>            content. Defaults to ``False``.<br/>        :param verify: (optional) Either a boolean, in which case it controls whether we verify<br/>            the server&#x27;s TLS certificate, or a string, in which case it must be a path<br/>            to a CA bundle to use. Defaults to ``True``. When set to<br/>            ``False``, requests will accept any TLS certificate presented by<br/>            the server, and will ignore hostname mismatches and/or expired<br/>            certificates, which will make your application vulnerable to<br/>            man-in-the-middle (MitM) attacks. Setting verify to ``False``<br/>            may be useful during local development or testing.<br/>        :param cert: (optional) if String, path to ssl client cert file (.pem).<br/>            If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Create the Request.<br/>        req = Request(<br/>            method=method.upper(),<br/>            url=url,<br/>            headers=headers,<br/>            files=files,<br/>            data=data or {},<br/>            json=json,<br/>            params=params or {},<br/>            auth=auth,<br/>            cookies=cookies,<br/>            hooks=hooks,<br/>        )<br/>        prep = self.prepare_request(req)<br/>    <br/>        proxies = proxies or {}<br/>    <br/>        settings = self.merge_environment_settings(<br/>            prep.url, proxies, stream, verify, cert<br/>        )<br/>    <br/>        # Send the request.<br/>        send_kwargs = {<br/>            &quot;timeout&quot;: timeout,<br/>            &quot;allow_redirects&quot;: allow_redirects,<br/>        }<br/>        send_kwargs.update(settings)<br/>&gt;       resp = self.send(prep, **send_kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:589: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;<br/>request = &lt;PreparedRequest [GET]&gt;<br/>kwargs = {&#x27;cert&#x27;: None, &#x27;proxies&#x27;: OrderedDict(), &#x27;stream&#x27;: False, &#x27;timeout&#x27;: 60, ...}<br/>allow_redirects = True, stream = False, hooks = {&#x27;response&#x27;: []}<br/>adapter = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6bbde10&gt;<br/>start = 1729753615.8633437<br/><br/>    def send(self, request, **kwargs):<br/>        &quot;&quot;&quot;Send a given PreparedRequest.<br/>    <br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>        # Set defaults that the hooks can utilize to ensure they always have<br/>        # the correct parameters to reproduce the previous request.<br/>        kwargs.setdefault(&quot;stream&quot;, self.stream)<br/>        kwargs.setdefault(&quot;verify&quot;, self.verify)<br/>        kwargs.setdefault(&quot;cert&quot;, self.cert)<br/>        if &quot;proxies&quot; not in kwargs:<br/>            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)<br/>    <br/>        # It&#x27;s possible that users might accidentally send a Request object.<br/>        # Guard against that specific failure case.<br/>        if isinstance(request, Request):<br/>            raise ValueError(&quot;You can only send PreparedRequests.&quot;)<br/>    <br/>        # Set up variables needed for resolve_redirects and dispatching of hooks<br/>        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)<br/>        stream = kwargs.get(&quot;stream&quot;)<br/>        hooks = request.hooks<br/>    <br/>        # Get the appropriate adapter to use<br/>        adapter = self.get_adapter(url=request.url)<br/>    <br/>        # Start time (approximately) of the request<br/>        start = preferred_clock()<br/>    <br/>        # Send the request<br/>&gt;       r = adapter.send(request, **kwargs)<br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/sessions.py:703: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.transport.unixconn.UnixHTTPAdapter object at 0x7f9ab6bbde10&gt;<br/>request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = 60, verify = True<br/>cert = None, proxies = OrderedDict()<br/><br/>    def send(<br/>        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None<br/>    ):<br/>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.<br/>    <br/>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.<br/>        :param stream: (optional) Whether to stream the request content.<br/>        :param timeout: (optional) How long to wait for the server to send<br/>            data before giving up, as a float, or a :ref:`(connect timeout,<br/>            read timeout) &lt;timeouts&gt;` tuple.<br/>        :type timeout: float or tuple or urllib3 Timeout object<br/>        :param verify: (optional) Either a boolean, in which case it controls whether<br/>            we verify the server&#x27;s TLS certificate, or a string, in which case it<br/>            must be a path to a CA bundle to use<br/>        :param cert: (optional) Any user-provided SSL certificate to be trusted.<br/>        :param proxies: (optional) The proxies dictionary to apply to the request.<br/>        :rtype: requests.Response<br/>        &quot;&quot;&quot;<br/>    <br/>        try:<br/>            conn = self.get_connection_with_tls_context(<br/>                request, verify, proxies=proxies, cert=cert<br/>            )<br/>        except LocationValueError as e:<br/>&gt;           raise InvalidURL(e, request=request)<br/><span class="error">E           requests.exceptions.InvalidURL: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/requests/adapters.py:637: InvalidURL<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;tests.test_original.Test testMethod=test_switchover_with_squelch&gt;<br/>args = (&#x27;test_switchover_with_squelch&#x27;,), kwargs = {}<br/><br/>    def __init__(self, *args, **kwargs):<br/>        super().__init__(*args, **kwargs)<br/>&gt;       self.env = Environment()<br/><br/>tests/test_original.py:16: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>environment.py:26: in __init__<br/>    self.client = docker.from_env()<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:96: in from_env<br/>    return cls(<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/client.py:45: in __init__<br/>    self.api = APIClient(*args, **kwargs)<br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:197: in __init__<br/>    self._version = self._retrieve_server_version()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;docker.api.client.APIClient object at 0x7f9ab6bbd550&gt;<br/><br/>    def _retrieve_server_version(self):<br/>        try:<br/>            return self.version(api_version=False)[&quot;ApiVersion&quot;]<br/>        except KeyError:<br/>            raise DockerException(<br/>                &#x27;Invalid response from docker daemon: key &quot;ApiVersion&quot;&#x27;<br/>                &#x27; is missing.&#x27;<br/>            )<br/>        except Exception as e:<br/>&gt;           raise DockerException(<br/>                f&#x27;Error while fetching server API version: {e}&#x27;<br/>            )<br/><span class="error">E           docker.errors.DockerException: Error while fetching server API version: Not supported URL scheme http+docker</span><br/><br/>/opt/hostedtoolcache/Python/3.11.10/x64/lib/python3.11/site-packages/docker/api/client.py:221: DockerException<br/></div></td></tr></tbody></table></body></html>